해시 테이블
==============================
    - *해싱(Hashing)을 사용해 시간복잡도가 O(n), O(log N)이 되는 방법 보다 효율적으로 검색하는 법
    - 해시 함수를 통해 얻은 해시 값을 

> 1) 해시 테이블
---------------

* 해싱( Hashing )
    - 각각의 데이터를 가급적 고유한 숫자 값으로 표현, 나중에 같은 숫자 값을 사용해 데이터의 유무를 확인하거나 해당 숫자에 대응하는 원본 데이터를 추출하는 작업

* 해시 함수
    - 데이터 원소를 인자로 받고 정해진 범위의 정수를 반환함
    - ex) 정해진 정수로 나눈 나머지를 반환하는 모듈로 함수( % )
        
* 해시 값
    - 해시 함수에 의해 반환되는 숫자 값

* 충돌 
    - 해시 함수가 서로 다른 키에 대한 같은 해시 값을 반환함으로써, 다수의 키가 같은 값을 갖게 되는 현상

* 부하율( load factor )
    - 각각의 리스트에 저장되는 키의 평균 개수
    - 부하율 = 전체 키 개수 / 해시 테이블 크기
    - 1에 가까울 수록 이상인 상태로 1보다 작으면 메모리 낭비, 1보다 크면 리스트의 평균 길이가 1보다 큰 의미

> 2) 충돌을 해결하는 방법
----------------------
* 체이닝
    - 하나의 키를 저장하는 것이 아니라 하나의 연결 리스트를 저장해 새로 삽입된 키에 의해 충돌이 발생하면 리스트의 맨 뒤에 새로운 키를 추가함.
    - 백터 대신 연결 리스트를 사용하는 이유는 특정 위치의 원소를 빠르게 삭제하기 위함

* 열린 주소 지정
    - 모든 원소를 해시 테이블 내부에 저장하는 방식, 반드시 테이블의 크기가 반드시 데이터 개수보다 커야 함
    - 특정 해시 값에 해당하는 위치가 이미 사용되고 있다면 테이블의 다른 비어 있는 위치를 탐색하는 것

    - 비어 있는 위치를 탐색하는 방법
        - 선형 탐색 ( liner probing )
        -> 특정 해시 값에서 충돌이 발생하면 해당 위치에서 하나씩 다음 셀 위치로 이동하면서 비어있는 셀에 원소를 삽입
        -> 데이터가 특정위치에 군집화 되는 경우에 문제가 발생
        
        - 이차함수 탐색
        -> 선형 방정식이 아닌 이차 방정식을 사용해 탐색을 수행함
        -> 새로 삽입하는 원소와 다른 해시값을 가질 수도 있어 특정 해시 값을 갖는 키가 오직 하나만 존재해도 충돌이 발생 할 수 있음 
        

> 3) 뻐꾸기 해싱
---------------
- 다른 방법들은 최악의 상황에서는 O(1)을 보장하지 않지만, 뻐꾸기 해싱은 구현만 제대로라면 O(1)을 만족함.
- 크기가 다른 두 개의 해시 테이블을 사용, 각각의 테이블은 서로 다른 해시 함수를 가짐.
- 모든 원소는 두 해시 테이블 중 하나에 있을 수 있으며, 위치는 해당 해시 테이블의 해시 함수에 의해 결정됨.

* 특이점
    - 원소가 두 해시 테이블 중 어디든 저장 가능
    - 원소가 나중에 다른 위치로 이동 가능
    

> 4) C++ 해시 테이블
--------------------
* 해시 구현에서 항상 정만 취급할 수는 없기 때문에, 문자열로부터 해시 값을 생성하는 용도로 사용. ( std::hash<std::string>(std::string) ) -> 함수 객체를 제공
    - std::unordered_set<Key> : 키만 저장 가능
    - std::unordered_map<Key, Value> : 키와 값을 함께 저장 가능
    - 두 컨테이너 모두 체이닝을 사용하는 해시 테이블 형태로 구현, 각 행은 키 또는 키와 값의 쌍을 저장하는 벡터로 여기서 각 행은 버킷( Bucket )이라 함.
    - 최대 1의 부하율을 가지고, 부하율이 커지면 해시 테이블 크기를 키우고 재해싱을 시작, 부하율을 1 이하로 떨어뜨림.