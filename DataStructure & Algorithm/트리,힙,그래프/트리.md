트리
===============================

> 1) 비선형 데이터 표현
----------------------
    - 선형 자료구조로 표현할 수 없는 '계층적 문제'와 '순환 종속성 문제'같은
    다양한 유형의 연산을 수행하기 위해 사용함

> 2) 트리
---------
    - 노드와 노드 사이를 연결하는 에지를 이용하여 계층을 구성
    - 중심의 되는 노드를 "루트 노드 ( Root Node )"라 부르며 맨위에 나타냄
    - 그림으로 나타내면 실제 나무와 반대로 뿌리가 맨 위에 있는 반전된 형태

> 3) 트리 순회
-------------
    - 전위 순회( preorder traversal) :
        -> 현재 노드를 먼저 방문하고 다음으로 왼쪽, 마지막으로 오른쪽을 재귀적인 방식으로 방문하는 순회법.

```c++
 static void preOrder(node* start)
 {
    if(!start)
        return;

    std::cout << start->position << ", ";
    preOrder(start->first);
    preOrder(start->second);
 };
```

 - 중위 순회( in-order traversal) :
        -> 왼쪽 노드를 먼저, 다음으로 현재 노드, 오른쪽을 마지막으로 방문

```c++
 static void inOrder(node* start)
 {
    if(!start)
        return;

    inOrder(start->first);
    std::cout << start->position << ", ";
    inOrder(start->second);
 };
```

 - 후위 순회( post-order traversal) :
        -> 두 자식 노드를 먼저 방문후, 현재 노드를 방문

```c++
 static void postOrder(node* start)
 {
    if(!start)
        return;

    postOrder(start->first);
    postOrder(start->second);
    std::cout << start->position << ", ";
 };
```

- 레벨 순서 순회( level order traversal) :
        -> 트리의 맨 위 레벨부터 아래 레벨까지 왼쪽에서 오른쪽으로 방문
        트리의 루트 노드부터 단계별로 차례대료 나열한것과 같음.

```c++
 static void levelOrder(node* start)
 {
    if(!start)
        return;

    std::queue<node*> q;
    q.push(start);

    while(!q.empty())
    {
        int size = q.size();
        for (int i = 0; i < size; i ++)
        {
            auto current = q.front();
            q.pop();

            std::cout << current->position << ", ";
            if(current->first)
                q.push(current->first);
            if(current->second)
                q.push(current->second);
        }

        std::cout << std::endl;
    }
 };
```