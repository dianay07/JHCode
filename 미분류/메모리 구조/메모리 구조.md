메모리 구조( Memory Structure )
==============
-> 한정된 자원안에서 효율적으로 프로그램이 실행 될 수 있도록 하기 위해서는 메모리에 대한 이해가 필요
) 메모리와 코딩 한 것들의 관계

![screenshot](/%EC%9D%B4%EB%AF%B8%EC%A7%80/image.png)

Static 영역
---

=하위 메모리 주소=
### Code(Text)
    - Read-Only 변수가 저장되는 공간
    - 작성하는 코드 부분, Section."text"로 시작됨
    - 프로그램 실행도중 수정이 불가능
    - 일반적으로 프로그램상 가장 하단부에 존재

### Data
    - 전역, 정적변수 등이 초기화되는 영역
    - 변수들이 프로그램이 끝날때까지 메모리에 남아있어 일정 메모리 접근 공간으로 사용 가능
    - 실행도중 자유롭게 접근해 수정 및 변경이 가능
    - Label을 통한 주소로 접근이 가능
    
    
### Bss 
    - Data와 마찬가지로 초기화 시키는 영역
    - 메모리상 공간만 잡아놓고 실제로 초기화 시키지 않음
        => 어느정도의 공간의 크리를 저장할 것이라는 정보를 저장
    ( 초기화된 변수 영역 / 초기화되지 않은 변수 영역(BSS) => 초기화 안하면 모두 0으로 되는데 이 0으로 초기화하는 자리가 아까워 어떻게 절약할까 생각한 결과 )

### Heap
    - 동적으로 할당 할 변수들이 저장되는 영역
    - 대개 낮은 주소에서 높은 주소로 할당
    - 공간이 비교적 큼

### Stack
    - 함수를 호출 할때 지역, 매개변수들이 저장되는 공간
    - 함수가 종료되면 해당 함수에 할당된 변수들을 메모리에서 해제시킴
    - 공간이 작음
    - 대개 높은 주소에서 낮은 주소로 할당
=상위 메모리 주소=


OTHER
---

* 스택 메모리
    - 레지스터의 다양한 용도
    - 범용 레지스터, 포인터 레지스터 
    - ip (Instruction Pointer) : 다음 수행 명령어의 위치
    - sp (Stack Pointer) : 현재 스택 top 위치 (일종의 cursor)
    - bp (Base Pointer) : 스택 상대주소 계산용
        => 함수안에서 새 함수를 호출할때 연산후 반환해야하는 줄, 위치를 저장하는 
 

* 메모리 주소 ( Memory Address )
    - 운영체제의 32bit, 64bit는 각각 4바이트, 8바이트의 메모리 한칸의 크기를 가짐
    - 때문에 포인터의 크기도 운영체제 마다 다름, 요즘은 32bit운영체제가 거의 없기때문에 보통 8byte의 크기를 갖는다가 대세.

* 오버플로우 ( Overflow )
    - 버퍼를 넘치게하는 상태, 주로 Stack과 Heap에서 데이터가 저장되면서 서로의 범위를 침범하거나 메모리의 할당 된 변수의 크기보다
     더 큰 데이터를 입력시키면 발생함.

* 지역 변수-스택, 동적할당 변수 - 힙에 각각 할당하는 이유 ?
    - 프로그램이 발달되어 스택으로만 해결 가능하던 환경에서 프로그램이 커짐으로 포인터를 이용한 동적 변수들을 사용해 메모리상 이득을 가지려함. 그 과정에서 스택과는 다른 공간의 필요성이 대두, 힙을 설정

    - 힙이란 공간의 이름은 사실 스택안에서 동적 할당을 위한 공간만을 따로 지칭한 것 -> 힙 오버플로우는 못들어봄


&& 참고
[http://shinluckyarchive.tistory.com/159];