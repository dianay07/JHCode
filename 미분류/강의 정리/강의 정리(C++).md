C++
======

변수
---
### 변수
    - 0이 아닌 초기화가 되어있으면, 즉 할당 되어 있다면 .data 영역
    - 초기값이 0 이거나 초기값이 없으면, 즉 할당 되지 않으면 .bss 영역
 
    - 선언과 할당을 동시에 : ' int x = 5; '
        => 메모리 주소 ???에 int 자료형 5의 값을 저장해라

### L-Value 와 R-Value
    - 일반적으로 대입 연산자(=)의 왼쪽은 L-Value, 오른쪽은 R-Value라 함

    - L-Value : 메모리상에서 지속적인 주소(위치)를 가진 값
        -> 표현식 이후 에도 없어지지 않고 지속
        -> 변수들은 주소를 가지고 있으니 모두 L-Vlaue
        -> 참조가 가능한 데이터 객체

    - R-Value : 표현식이 종료된 이후 더이상 존재하지 않는 임시적인 값
        -> 지속적인 메모리 주소와 관련이 없는 값
        -> x에 3이 있을때, 5 와 x + 2는 같은 값으로 평가됨

### 자동 공간, 정적 공간, 동적 공간
    - 자동 공간 :
        -> 생성시 스택에 저장, 순차적으로 저장되고, 역순으로 해제
        -> 자신들을 포함하는 블록 안에서만 유효

    - 정적 공간 :
        -> 프로그램이 실행되는 동안 지속적으로 존재하는 공간
        -> 함수의 외부에서 변수 정의, 혹은 static 키워드 변수

    - 동적 공간 : 
        -> new와 delete를 사용하는 공간
        -> 힙에 데이터 생성
        -> 자유공간이라 부르는 메모리 풀을 관리

데이터
---
### 정수
    - char    a; => 1 바이트
    - short   b; => 2 바이트
    - int     c; => 4 바이트        : 다른 체제와 통일성을 위해 int32로도
    - __int64 d; => 8 바이트 (long long)

    - bool       => 1 바이트 정수
        -> true, false 1비트 하나만 사용하지만 bool은 1바이트를 차지
        -> 1비트 사용하고 7비트 낭비한 것

### 실수(부동소수점)
    - .(점) 을 유동적으로 움직여서 표현하는 방법
        -> 프로그래밍 상 항상 근삿값, 특정 유효 자릿수까지만 저장하고 나머지는 손실됨

    - 정밀도(Precision)
        -> 정보 손실 없이 나타낼 수 있는 유의한 자릿수
        -> std::cout의 기본 정밀도는 '6'
        -> <iomanip>의 std::setprecision()으로 정밀도의 재정의가 가능
        -> 정밀도를 넘어선 크기를 출력시 예상하지 못한 결과가 출력됨

    - float  => 4 바이트
        -> 부호(1) 지수(8) 유효숫자(23) = 32비트
        -> 정밀도 6 ~ 9
    - double => 8 바이트 (기본 자료형)
        -> 부호(1) 지수(11) 유효숫자(52) = 64비트
        -> 정밀도 15 ~ 18

    ex) -3.375
        => 1) 2진수 변환 = (3) + (0.375) = ob11 + 0b0.011
           2) 정규화 = 0b1.1011 * 2

    1(부호) 1(지수) 1011(유효숫자)
    단 지수는 unsigned byte라고 가정하고 숫자 + 127 만들어줌

### 공용체 ( Union )
    - 서로 다른 데이터형을 한번에 한 가지만 보관할 수 있는 데이터 형식
    - 여러 가지 데이텨형을 사용 가능하지만, 동시에 사용할 수 없을 떄, 사용하면 메모리 절약이 가능
    - 일반적으로 메모리 공간에 저장

### 문자와 문자열
    - 문자
        -> char    : 알파벳 / 숫자 문자              // cout
        -> wchar_t : 유니코드 문자 (UTF16 으로 저장) // mcout

    - 인코딩 형식       
    UTF8
        -> 알파벳, 숫자 1바이트(ASCII 동일한 번호)
        -> 유럽 지역의 문자는 2바이트
        -> 한글, 한자 등 3바이트
       
    UTF16
        -> 알파벳, 숫자, 한글, 한자 등 거의 대부분 2바이트
        -> 매--우 예외적인 고대 문자만 4바이트(사실상 x)

    - 이스케이프 시퀸스
        \t = 아스키코드9  = Tab
        \n = 아스키코드10 = LineFeed (한줄 아래로)
        \r = 아스키코드13 = CarriageReturn (커서 <<)
        \' = 따옴표같은 문자 표시
        \0 = 아스키코드0  = NULL

    - 문자열
        -> 문자열의 끝은 NULL (ASCII 0)
        -> Data 영역에서 초기화하면 0으로 초기화되서 잘 나오지만 Stack 영역에서 초기화하면 0이 없어 0이 나올때까지 멋대로 찾아다녀 쓰레기 값이 나옴
        -> ""를 이용해서 초기화하면 뒤에 NULL이 자동으로 추가

    - String 클래스
        -> 단순한 변수로 선언하고 char 문자 배열처럼 사용 가능
        -> 결합을 +, += 연산자를 이용해 간단히 처리
        -> 필요시 크기를 자동으로 조절해 메모리 침범을 예방

### 비트 연산
    - 변수 내의 비트를 조작
        -> signed 변수에서 적용방식을 보장하지 않아 ( 부호가 바뀔수 있어 ),
           unsigned 자료형을 사용해야 함
        -> C++에서 사용되는 비트 수는 자료형의 크기에 따라 달라짐
           ( byte당 8bit )
        -> 게임에서 ID를 검색할때, *BitFlag

    * bitwise 연산자 ?

    - 비트 연산자 종류
        << : 비트 좌측으로 이동
            -> 왼쪽에 넘치는 N개의 비트는 버리고 복원이 안됨. 오른쪽은 0으로 채움
            -> 비트 연산시 *2를 할때 컴파일러가 자주 하는 패턴

        >> : 비트 우측 이동
            -> 비트열을 N만큼 오른쪽으로 이동
            -> 마찬가지로 이동시 버리고 왼쪽에 생기는 N개의 비트는 ~부호    비트가 존재할 경우 부호 비트를 따라감, 아니면 0

        ~ : bitwise not 
            -> 단일 숫자의 모든 비트를 대상으로 0과 1을 서로 바꾼다

        & : bitwise and
            -> 두 숫자의 모든 비트 쌍을 대상으로 and 연산

        | : bitwise or
            -> 두 숫자의 모든 비트 쌍을 대상으로 or 연산

        ^ : bitwise xor
            -> 두 숫자의 모든 비트 쌍을 대상으로 xor 연산
            -> 암호화할떄 유용, 두번 xor 연산하면 오리지널이 나옴

#### 비트플래그
    - bool노가다를 줄이는 방법
        ex) unsigned char flag;
        
    - 0b0000 [무적][변이][스턴][공중부양]
    => flag = (1 << 3); = 무적 상태로 만듬
    => flag = (1 << 2); = 변이 상태로 만듬

    무적 + 변이
    => flag |= 4; // flag (1 << 2);

    확인 방법
    *bitmask

    // 무적인지 확인
    bool invincible (flag & (1 << 3)) != 0
    0이면 무적 아니면 아니고


### const와 메모리 구조
    - const 자료형 = 값;
        -> 초기값을 반드시 지정해야 함
        -> value값 자체를 변경할 수 없게 함


    메모리 구조
![Link](/%EB%AF%B8%EB%B6%84%EB%A5%98/%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B5%AC%EC%A1%B0/%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B5%AC%EC%A1%B0.md))

    - Data 영역 안에서
        -> .data -> 초기값 있는 경우
            => int a = 2;
        -> .bss -> 초기 값 없는 경우
            => int b;
        -> .rodata -> 읽기 전용 데이터
            => const char* msg = "Hello World"

    - const는 그럼 어디로 저장되는가??
        -> 사실 정해진건 없다, 컴파일러 마음
        -> 컴파일러가 자체적으로 설정 값으로 바꾸기 때문에 메모리 할당이 안되있을수도 있음

    - 함수내에서 const 변수를 만들면??
        -> 스택 영역에 만들어짐


유의사항
1) 변수의 유효범위
    - 함수 외부의 선언 했을때 => 전역 변수
    언제 어디서든 쓸 수있는

    - 특정 함수 내부에 선언 했을때 => 스택에 들어가는 변수, { } 의 범위가 생존 범우

2) 연산 우선순위
    - 연산자마다 우선순위가 있으니 유의
    - 필요한 경우 ( )로 감싸 변경

3) 타입 변환
    - 선언한 변수의 자료형을 바꿀때 -> 캐스팅

4) 사칙연산
    - 정수 / 정수를 실수에 저장하고 싶다면 소숫점 밑이 잘려 저장되기 때문에 float으로 저장해도 소숫점이 잘림


함수 ( 프로시저, 메소드, 루틴 )
---
    - c++의 프로그래밍 모듈 
    - 함수를 정의, 원형을 제공, 함수를 호출해 사용

### 함수의 호출
    - 프로그램을 다른 주소(함수의 주소)로 점프 시켰다가, 함수의 처리가 종결되면 다시 원래의 자리로 돌아오는 것

### 함수 원형의 '필요성
    - 어떠한 종류의 값이 몇 개 전달되어야 하며, 어떤 종류의 리턴값을 돌려 받는지에 대해 서술하는 함수의 인터페이스
        -> 함수의 원형을 컴파일 하기 위해 main()의 컴파일이 멈추는 비효율적인 행동을 방지 ( p.380 )
        -> 컴파일러가 함수의 리턴값을 바르게 처리
        -> 사용자가 정확한 수, 정확한 매개변수를 사용했는지 검사

### 지역 변수
    - 전역변수
        -> 메모리 구조 상 data영역에 저장
        -> 어디서든 꺼내서 사용 가능

    - 지역변수
        -> 메모리 구조 상 stack영역에 저장
        -> 함수 내부에서 선언되어 사용되는 변수
        
    ** 스택프레임 **
        -> 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역
        -> 함수가 호출될 때, 매개 변수, 반환 주소값, 지역 변수 등이 저장
        -> 3가지 요소가 저장되며 호출 될 때마다 스택에 저장되는 과정
        -> 즉, 그 함수만의 스택 영역을 구분하기 위해 생성되는 공간
    ![link]https://eliez3r.github.io/post/2019/10/16/study-system.Stack-Frame.html


### 오버로딩 ( 중복 정의 : 함수 이름의 재사용 ) *
        -> 매개변수 갯수가 다르거나
        -> 매개변수 타입이 다르거나 (순서가 다른걸 포함)
        -> 의 경우에 함수 이름을 재사용해 사용함
        -> " 여러 개의 함수를 같은 이름으로 연결 "
        -> 데이터형 자체와 그에 대한 참조를 같은 시그내처로 간주
        -> 기본적으로 같은 작업을 수행하는 함수들에만 사용

    - 기본 인자값
        -> 함수선언때 미리 기본값을 설정 가능
        -> 기본값을 정의할 변수는 항상 마지막에 정의

### 재귀 함수
    - 자기 자신을 호출

### 함수 포인터
    - 함수의 주소 : 함수에 해당하는 기계어 코드가 저장되어 있는 메모리 블록의 시작 주소
    - 첫 번째 함수가 다른 시각에 다른 함수를 사용할 수 있다는 것을 의미
    - Func(FuncName)   -> FuncName()의 주소를 전달
      Func(FuncName()) -> FuncName()의 리턴값을 전달  

```c++
    double pam(int a);
	double (*pf)(int a);

	pf = pam;
```

### 인라인(inline) 함수
    - '컴파일러가 코드를 프로그램에 어떻게 결합하느냐'의 차이
    - 호출 단계에서 거치는 스택에 주소를 저장, 점프하는 단계를 코드채로 삽입해 대체
    - 일반 함수보다 빠르지만 메모리 사용 측면에서 불리
    - 빈번히 호출되는 함수만 시간 절약 ( 재귀 호출을 허용하지 않음 )
    - 매개변수를 값으로 전달

### 값, 참조, 주소 반환
    - 값으로 반환 (Return by Value)
        -> 가장 간단하고 안전, 리터럴, 변수, 표현식을 리턴 가능
        -> 범위 지정 문제 X
        -> 구조체, 클래스 반환에 느림

    - 주소로 반환 (Return by address)
        -> 호출자에게 변수의 주소를 리턴
        -> 지역 변수의 주소 반환시 변수가 삭제되기 때문에 유의

    - 참조로 반환 (Return by reference)
        -> 참조를 사용해 계속 변수 수정 가능
        -> 리턴이 빨라 구조체와 클래스 리턴에 유용
        -> 배열 요소 반환에 능함

참조
---

### 참조 변수
    - 어떤 변수의 실제 이름 대신 쓸 수 있는 대용 이름
        -> 함수의 형식 매개변수에 사용 하는 것
        -> 이 함수는 복사본 대신 원본 데이터를 가지고 작업
        -> 한 개의 변수, 두 개의 이름
    - 원본 변수와 같은 값, 같은 주소를 가지고 있음
    - 참조를 먼저 선언하고 나중에 값을 지정 할 수 없음 
    - 구조체와 클래스와 같이 덩치 큰 데이터를 다룰 때 유익

### rvalue 참조 ( C++11 )
    - 18장

### 참조 매개변수
    - 호출 함수에 있는 데이터 객체의 변경을 허용하기 위해
    - 전체 데이터 객체 대신에 참조를 전달해 속도를 높이기 위해

포인터
---
### 포인터
    - 특정 공간에 있는 메모리에 접근 (강제로 조작할 수 있게) 하는방법       -> '주소'를 담는 변수
    - 주소를 저장하기 때문에 체계에 따라 크기가 다름
        -> 32비트 = 4바이트 / 64비트 = 8바이트 고정 크키
    - C++에서 동적으로 메모리를 할당할 수 있는 유일한 방법
    - 함수를 매개 변수로 다른 함수에 전달하는데 사용

    - 포인터에 타입을 정하는 이유
        -> 주소에 도착했을때 값이 어떤 형태인지 명시하기위해
        -> 자료형을 잘못 사용할경우 데이터 손실이 발생함    
        -> 자료형이 없으면 포인터는 역참조 시 가리키는 내용을 해석하는 방법을 알지 못함

    - 개념적으로 정수형과는 다른 데이터형이라 연산의 관점이 정수와 다름

    - 프로그램을 실행하는 동안 이름이 없는 메모리를 대입하는 것이 포인터의 진정한 가치

### 포인터 연산
    -주소 연산자(&)
        -> 해당 변수의 주소를 가져옴
        -> 정확히는 해당 변수 타입에 따라서 Type* 변환

    - 산술 연산자 (+ -)
        -> 포인터나 +나 -등 산술 연산하면 Type의 크기만큼 연산하라는 뜻

    - 간접 연산자 (*)
        -> 해당 주소로 가는것

    - 간접 멤버 연산자 (->)
        -> (*ABC).xxx = ABC->
        -> 구조체의 특정 멤버를 다룰때 사용 ( 어셈블리 언어로 보면 (.) 사실상 그냥  덧셈)

### new를 사용한 메모리 대입
    - C에서의 malloc() 대신 Unnamed 메모리를 대입하는 방법
    - new 연산자는 대입한 메모리의 주소를 리턴
    - 이름없는 공간을 지시하는 포인터는 '데이터 객체'라고 표현
    - typeName* pointer_name = new typeName;

    - 주소는 데이터형이나 바이트 수를 알려주지 않고 저장된 객체의 시작 주소만 전달
        -> new typeName으로 프로그램이 typeName에 맞춰 어떻게 해석할지를 결정
    
    - 사용후 반드시 delete를 이용해 메모리를 해제해야함

### 널 포인터
    - 메모리가 부족하여 new의 메모리 대입 요청을 허용할 수 없을 때 new는 0 값을 리턴하는데 이것이 '널 포인터'
    - 리턴해야하는 연산자나 함수에서 일이 안될때 사용

*포인터 vs 참조
1) 편의성 관련
-> 성능은 똑같고 편의성이 더 좋은 참조만 쓸수는 없음
-> 포인터는 주소나 원본을 넘기는지를 확실히 알 수 있으나 참조는 모르고 지나칠 수 있음, 즉 원본훼손의 여지를 느낄수 있음
=> 참조는 변경하지 말라고 const와 같이 사용 많이함 (const StatInfo& ...)

*const의 앞과 뒤에 *(포인터)가 붙는 의미
-> (type)* const .. = 변수의 주소값을 바꾸지못함 주소값 고정
-> const (type)* = 주소값이 아닌 주소안의 내용물을 바꾸지못함 = 내용물 고정


2) 초기화 여부
-> 참조 타입은 두번째 이름이기 때문에 참조하는 대상이 없으면 안됨.
-> 반면 포인터는 그냥 어떤 ~ 주소라는 의미 : 대상이 실존하지 않을 수도 있음
-> 포인터에서 '없다'는 의미는 ? : nullptr
-> 참조 타입은 이런 nullptr이 존재하지 않음.
=> 없다는 표현을 참조는 할 수 없는게 포인트

// 결론 //
답은 없고 Team by Team
구글은 포인터를 많이 쓰고 언리얼은 레퍼런스를 많이 쓰더라

================

*배열 
배열의 이름은 곧 배열의 시작주소
정확히는 시작 위치를 가리키는 type* 포인터

*포인터 vs 배열
-> 배열을 함수 인자로 넘기면, 컴파일러가 알아서 포인터로 치환 ( char[] -> char* )
=> 배열을 넘기는 것은 배열의 시작 주소를 넘긴것

*파일 분할 관리
헤더와 .cpp 파일의 대한 이야기
선언부와 구현부의 분할

#pragma once => 같은 부분을 두번 선언하지 않게끔 해주는
#indef ... #define .. #endif 라는 옛버전도 있음
헤더파일은 최대한 간단하게


# 객체지향의 시작
객체란?
---
-> 플레이어, 몬스터, GameRoom등의 오브젝트의 개념적 통칭
-> 일종의 설계도인  클래스의 등장
-> 다양한 변수의 유효범위들을 클래스라는 틀에 묶어 하나의 덩치로써 인식

생성자와 소멸자
---
-> 클래스내의 특별한 함수 2종
-> 시작의 생성자 (여러개 존재 가능)
-> 끝의 소멸자 (오직 1개만)

1) 기본 생성자 ( 인자가 없음 )
-> 아무것도 없어도 자동으로 호줄되는 기본 폼
-> 클래스 소속 멤버 변수들의 초기화 가능

) 암시적(implicit) 생성자
-> 생성자를 명시적으로 만들지 않으면 아무 인자도 받지 않는 기본 생성자가 컴파일러에 의해 자동으로 만들어짐
-> 프로그래머가 명시적으로 만들면 자동적으로 만들어주지 않음

2) 복사 생성자
-> TYPE(const TYPE& name) { }
-> 자기 클래스 참조 타입을 인자로 받음
-> 일반적으로 똑같은 데이터를 지닌 객체가 생성되길 기대

3) 그외... 기타 생성자 ( 타입 변환 생성자 )
-> 프로그래머 필요에 의한 내용

상속성
---
-> 부모 <=> 자식, 무언가를 물려주는 것, 코드 재사용성 향상
-> 상위 클래스의 기능들을 하위 클래스가 사용하면서 하위 클래스 하나만의 특징을 지정 할 수 있음
-> 메모리상 상위클래스가 먼저 생성된후 밑에 하위클래스가 생성
-> 하위클래스가 상위클래스의 기능, 함수를 재정의 가능
-> 하위클래스를 생성하면 상위클래스의 생성자를 먼저 부르고 소멸시킬 시에는 반대로 하위클래스의 소멸자를 먼저 부름
-> 상위클래스의 생성자의 종류도 명시적으로 사용가능
ex) type2(int ..) : type1(float ..)

은닉성 = 캡술화 ( 연관된 데이터와 함수를 논리적으로 묶어놓은 것)
---
-> 숨기는 이유 : ) 위험하고 건드리면 안되는 경우
) 다른 경로로 접근하길 원하는 경우
-> 상속 접근 지정자 : 다음 세대에게 상속 받은 내용을 어느정도까지 내려받을지
) public : 그래도 다
) protected : 자기 직속 하위클래스일때만, 1차 하위는 상속받지만 2차 하위는 못받음
) private : 안줌

다형성
---
-> 형태는 같지만, 기능이 다르게 동작 
( 오버로딩 : 함수 중복 정의 = 함수 이름의 재사용 오버라이딩 : 재정의 = 상위 클래스의 함수를 하위 클래스에서 재정의)
-> 바인딩
    => 정적 바인딩(static binding) : 컴파일 시점에 결정
    => 동적 바인딩(dynamic binding) : 실행 시점에 결정
-> 일반 함수는 정적 바인딩을 실행
-> 동적 바인딩을 원한다면? -> 가상 함수 사용

*가상함수 테이블 (vftable)*
-> 실제 객체가 어떤타입인지 어떻게 알고 알아서 가상함수를 호출하는지의 대한 해답
-> 가상함수들의 주소들을 객체마다 저장하고 있다가 지정받은 객체 버전의 함수 주소로 가서 실행 

-> 순수 가상 함수 : 구현은 없고 인터페이스만 전달하는 용도로 사용하고 싶을 경우
-> 추상 클래스 : 순수 가상 함수가 1개 이상 포함되면 추상 클래스가 됨
    => 이는 직접적으로 객체를 만들 수 없게 됨
    => 하위 클래스가 어떻게는 순수 가상 함수를 재정의해서 사용해야함


초기화 리스트
---
-> 초기화를 해야 하는 이유
    => 버그 예방에 중요
    => 포인터 등 주소값이 연루되어 있을 경우

-> 초기화 방법
    => 생성자 내에서
    => *초기화 리스트
        - 상속 관계에서 원하는 부모 생성자 호출할때 필요
        - 생성자 내에서 초기화 vs 초기화 리스트
        > 일반 변수는 별 차이 없음
        > 멤버 타입이 클래스인 경우 차이가 남
        > 정의함과 동시에 초기화가 필요한 경우 ( 참조 타입, const 타입)
    => C++11 문법
        type name = 바로 ;
-> 두 클래스가 상속 관계였을 경우 전처리 영역외에 클래스의 정의를 내릴경우 객체가 한개 더 생길 수 있음

연산자 오버로딩
---
기본으로 제공되는 연산을 제외한 커스텀 연산이 필요할떄 사용

함수 오버로딩과 다른점 : 연산자는 피연산자의 개수/타입이 고정되어 있음

  -RET operator+ (ARG_List) { }-

-멤버 연산자 함수
-> a op b 형태에서 왼쪽을 기준으로 실행됨 (a가 클래스여야 가능, a를 '기준 피연산자'라고 함)
    => 한계) a가 클래스가 아니면 사용 못함

-전역 연산자 함수
-> a op b 형태라면, a,b모두를 연산자 함수의 피연산자로 만등러줌
-> 멤버 연산자 함수의 한계를 극복하려는 것
-> 대입 연산자(=)는 전역에서 생성이 불가능

-복사 대입 연산자

-static 변수, static 함수
-> 클래스변수와 비슷하지만 단일 객체에 연관이 아니라 그 객체 자체와 연관됨

-> static 함수는 전역함수처럼 동작하기 때문에 static 변수를 건드릴땐 문제없지만 특정 객체와 연관성이 생기면 안됨

-> 초기화 하면 .data 영역, 안하면 .bss 영역에 저장됨

# 동적 할당
메모리 구조 복습
-실행할 코드가 저장되는 영역 -> 코드 영역
-전역(global)/정적(static)변수 -> 데이터 영역

-지역 변수/매개 변수 -> 스택 영역
-함수가 끝나면 같이 정리되는 불안정한 메모리
    -> 잠시 함수에 매개변수 넘긴다거나, 하는 용도

-동적 할당 -> 힙 영역
    -> 필요할때만 사용, 필요없으면 반납
    -> 생성/소멸 시점을 관리 가능
---

/ 유저영역(메모장, 롤, 곰플레이어)
/ ------------------
/ 커널영역 ( Windows 핵심 코드)

-유저가 운영체제에서 제공하는 API를 호출하면 커널 영역에서 메모리를 할당해서 건네줌

-C++에서는 CRT(C런타임 라이브러리)의 [힙 관리자]를 통해 힙 영역 사용.
-정말 원하면 직접 API를 통해 힙을 생성하고 관리 가능 ( MMORPG 서버 메모리 풀링 )

-malloc
    -> 할당할 메모리 크기를 건네줌
    -> 메모리 할당 후 시작 주소를 가리키는 포인터를 반환 ( 메모리 부족시 NULL )
    -> void* 형태를 반환하나 아무것도 없다는 뜻이 아니라 뭐가 쓰일지 모른다는 뜻

-free
    -> malloc 같은 메모리 할당을 통해 할당된 영역을 해제
    -> 힙 관리자가 할당/미할당 여부를 구분해서 관리

-new / delete 가 위 예시보다 편의성이 좋음
-타입에 상관없이 특정한 크기의 메모리 영역을 할당 받으려면 malloc / free가 좋음

-둘의 차이 첫째는 malloc/free는 함수, new/delete는 연산자임
-둘의 근본적인 차이는 
'new/delete'는 생성타입이 클래스일 경우 생성자/소멸자를 호출함  

# 타입변환

타입 변환 유형 ( 비트형 재구성 여부 )
---
1) 값 타입 변환
    -> 의미를 유지하기 위해, 원본 객체와 다른 비트열 재구성 
2) 참조 타입 변환
    -> 비트열을 재구성하지 않고, 관점만 바꾸는 것

안전도 분류
---
1) 안전한 변환
    -> 의미가 항상 100퍼 완전히 일치하는 경우
    -> 같은 타입이면서 크기만 더 큰 바구니로 이동
2) 불안전한 변환
    -> 의미가 항상 100퍼 일치하낟고 보장 못함
    -> 타입이 다르거나 정수에서 실수로 바꾸는 등
    -> 같은 타입이나 큰 쪽에서 작은쪽으로 다운 캐스팅하는등

프로그래머 의도에 따른 분류
---
1) 암시적 변환
    -> 이미 알려진 타입 변환 규칙에 따라서 컴파일러 자동으로 타입 변환

2) 명시적 변환
    
클래스 사이의 변환
---
1_ 연관없는 클래스 사이의 '값 타입' 변횐
    -> 일반적으로 안됨 ( 예외 : 타입 변환 생성자, 타입 변환 연산자를 만들어주면 댐)

2) 연관없는 클래스 사이의 참조 타입 변환
    -> 명시적으로는 가능

3) 상속 관계에 있는 클래스 사이의 변환
    -> 자식에서 부모로는 OK, 부모에서 자식으로는 X

4) 상속 관계에 있는 클래스의 참조 타입 변환
    -> 상당히 자유로움

결론 => 
[값 타입 변횐] : 진짜 비트열도 바꾸고 논리적으로 말이 되게 바꾸는 변환
-논리적으로 말이 된다? ex) 불독 -> 개
-논리적으로 말이 안된다 ex) 개 -> 불독, 개 -> 기사

[참조 타입 변환] : 비트열은 냅두고 우리의 관점만 바꾸는 변환
-명시적으로 요구하면 해주는데 암시적으로는 안전성 여부와 연관이 있어 컴파일러가 판단 후 해줌
-메모리 침범 위험이 있는경우 그냥 해주지 않음


포인터 타입변환
---
[연관성이 없는 클래스 사이의 포인터 변환]
암시적으로는 X, 명시적으로는 O
접근도 할 수 있는데 내용물이 다르니까 쓰레기값이 들어가있음

-캐스팅을 잘 이용하면 부모클래스로 하위클래스들이 가지고 있는 공통기능들을 효율적으로 컨트롤할 수 있음

-다만 이런식으로 생성시, 생성자가 부모, 자식 모두 호출되기 때문에 소멸시킬때도 원래 소멸자가 호출되는 순서를 맞춰줘야함
    -> 소멸자를 가상함수로 작성하면, 가상함수 테이블과 같은 원리로 원본타입의 소멸자를 불러 소멸시켜줌
    -> 부모 클래스의 소멸자는 항상 가상함수로 작성해라

[결론] : 포인터 vs 일반타입의 차이를 이해
        포인터 사이의 타입변환(캐스팅)은 매우 조심해야함
        부모-자식 관계에서 부모 클래스의 소멸자에는 까먹지 말고 virual을 붙여야함

    ** 이유 : 상속관계에 의해 함수를 재정의 해봣자 한놈만 골라서 실행되기 때문에 가상함수로 만들어주면 가상함수테이블로 인해 본인 타입에 맞는 함수가 실행됨 **


# 얕은 복사 vs 깊은 복사
복사 생성자 + 복사 대입 연산자
-> 둘 다 안 만들어주면 컴파일러가 암시적으로 만듬

-얕은 복사
    -> 멤버 데이터를 비트열 단위로 똑같이 복사 ( 메모리 영역 값을 그대로 복사)
    -> 포인터를 그대로 복사할시 동일한 객체를 가리키기 떄문에 문제가 발생

-깊은 복사
    -> 멤버 데이터가 참조 값이라면, 데이터를 새로 만들어줌 ( 원본 객체가 참조하는 대상까지 새로 만듬

---
-암시적 복사 생성자 steps
1) 부모 클래스의 복사 생성자 호출
2) 멤버 클래스의 복사 생성자 호출
3) 멤버가 기본 타입일 경우 메모리 복사 ( 얕은 복사 )

-명시적 복사 생성자 step -> 프로그래머가 다해야댐
1) 부모 클래스의 기본 생성자 호출
2) 멤버 클래스의 기본 생성자 호출

-암시적 복사 대입 연산자 steps
1) 부모 클래스의 복사 대입 연산자 호출
2) 멤버 클래스의 복사 대입 연산자 호출
3) 멤버가 기본 타입일 경우 메모리 복사 (얕은 복사)

-명시적 복사 대입 연산자 steps
1) 알아서 해준느거 없음

->>
객체를 복사한다는 것은 두 객체를 일치시키려는 것
따라서 기본적으로 얕은 복사 방식으로 동작


# 캐스팅 4종( 타입 변환 )
1) static_cast
    -> 타입 원칙에 비춰볼 때 상식적인 캐스팅만 허용
    -> int <-> float
    -> Player* knight* ( 부모 -> 자식 다운캐스팅 ) 단, 안정성 보장 못함

2) dynamic_cast
    -> 상속 관계에서의 안전한 형변환
    -> RTTI (RunTime Type Information) : 다형성을 활용하는 방식
    -> 가상함수를 하나라도 만들면, 객체의 메모리에 가상함수 테이블 주소가 기입되어 그것을 이용
    ** 만약 잘못된 타입으로 캐스팅을 하면, nullptr 반환 **
    -> 이를 이용해 맞는 타입으로 캐스팅 했는지 확인이 유용

3) const_cast
    -> const를 붙이거나 때거나

4) reinterpret_cast
    -> 가장 위험하고 강력한 형태의 캐스팅
    -> 포인터랑 전혀 관계없는 다른 타입 변환

# 콜백 함수
함수포인터
---
1) 함수 포인터
    -> 포인터 *
    -> 변수의 이름 fn
    -> 타입 함수 ( 인자로 뭘 받고, 뭘 반환 )
    -> ex) int(*fn)(int, int);

typdef Type(name)(매개변수);
-> name* fn; 함수의 주소를 담은 포인터

선언한 함수의 시그니쳐가 같으면 함수포인터 사용가능
다른 함수의 매개변수에 동작으로써 넣어줄 수 있음

-> 이 문법은 [전역, 정적 함수]만 호출 가능

2) 멤버 함수에 대한 함수 포인터
    -> int(class::*fn)(int, int);

PMEMFUNC mfn;
k1.GetHP(1,1);

mfn = &Knight::GetHP;
(k1.*mfn)(1,1);


함수 객체 ( Functor )
---
함수 포인터 단점
1) 시그니처가 안 맞으면 사용할 수 없음
2) 상태를 가질 수 없음 ( *상태 ?)

함수 객체 => 함수처럼 동작하는 객체
-> () 연산자 오버로딩 필요


템플릿 기초
---
템플릿 : 함수나 클래스를 찍어내는 툴
1-1) 함수 탬플릿 :
    template<typename T> ...

1-2) 연산자 오버로딩
    ostreame& operater...(ostream& os, ...)

1-3) 템플릿 특수화 ( 예시는 Knight가 들어갈때 전용)
    template<(비워둠)>
void Print(Knight a)
{
    ....
}

2) 클래스 탬플릿
    template<typename T>
class name
{
    ...
}
name<type> class1;


콜백 ( Callback )
---
함수 포인터 + 함수 객체 + 템플릿
어떤 상황이 일어나면 -> 이 기능을 호출해라