C++
======

스택에서
--------
0이 아닌 초기화가 되어있으면 .data 영역
초기값이 0 이거나 초기값이 없으면 .bss 영역


정수
---
char a; => 1 바이트
short b; => 2 바이트
int c; => 4 바이트
__int64 d; => 8 바이트 (long long)

bool => 1 바이트 정수에 불과

실수(부동소수점)
---
.(점) 을 유동적으로 움직여서 표현하는 방법
    -> 프로그래밍 상 항상 근삿값

float => 4 바이트
    - 부호(1) 지수(8) 유효숫자(23) = 32비트
double => 8 바이트, (기본 자료형)
    - 부호(1) 지수(11) 유효숫자(52) = 64비트

ex) -3.375
    => 1) 2진수 변환 = (3) + (0.375) = ob11 + 0b0.011
       2) 정규화 = 0b1.1011 * 2
    
    1(부호) 1(지수) 1011(유효숫자)
    단 지수는 unsigned byte라고 가정하고 숫자 + 127 만들어줌


문자와 문자열
---
문자
char : 알파벳 / 숫자 문자   // cout
wchar_t : 유니코드 문자 (UTF16 으로 저장) // mcout

UTF8
-> 알파벳, 숫자 1바이트(ASCII 동일한 번호)
-> 유럽 지역의 문자는 2바이트
-> 한글, 한자 등 3바이트
UTF16
-> 알파벳, 숫자, 한글, 한자 등 거의 대부분 2바이트
-> 매--우 예외적인 고대 문자만 4바이트(사실상 x)

\t = 아스키코드9 = Tab
\n = 아스키코드10 = LineFeed (한줄 아래로)
\r = 아스키코드13 = CarriageReturn (커서 <<)
\' = 따옴표같은 문자 표시
\0 = 아스키코드0 = NULL

문자열
끝은 NULL (ASCII 0)
Data 영역에서 초기화하면 0으로 초기화되서 잘 나오지만 Stack 영역에서 초기화하면 0이 없어 0이 나올때까지 멋대로 찾아다녀 쓰레기 값이 나옴

""를 이용해서 초기화하면 뒤에 NULL이 붙음

비트 연산
---
비트 단위의 조작이 필요할 때
-> 게임에서 ID를 검색할때, *BitFlag

~ : bitwise not 
=> 단일 숫자의 모든 비트를 대상으로 , 0은 1, 1은 0으로 뒤바꿈

& : bitwise and
=> 두 숫자의 모든 비트 쌍을 대상으로 and 연산

| : bitwise or
=> 두 숫자의 모든 비트 쌍을 대상으로 or 연산

^ : bitwise xor
=> 두 숫자의 모든 비트 쌍을 대상으로 xor 연산
=> 암호화할떄 유용, 두번 xor 연산하면 오리지널이 나옴

<< : 비트 좌측으로 이동
=> 왼쪽에 넘치는 N개의 비트는 버리고 복원이 안됨. 오른쪽은 0으로 채움
=> 비트 연산시 *2를 할때 컴파일러가 자주 하는 패턴

'>> : 비트 우측 이동
=> 비트열을 N만큼 오른쪽으로 이동
=> 마찬가지로 이동시 버리고 왼쪽에 생기는 N개의 비트는 ~부호 비트가 존재할 경우 부호 비트를 따라감, 아니면 0

*비트플래그
-> bool노가다를 줄이는 방법

ex) unsigned char flag; // 부호를 없애야 >>를 해도 부호가 안따라옴

-- 0b0000 [무적][변이][스턴][공중부양]
=> flag = (1 << 3); = 무적 상태로 만듬
=> flag = (1 << 2); = 변이 상태로 만듬

무적 + 변이
=> flag |= 4; // flag (1 << 2);

확인 방법
*bitmask

// 무적인지 확인
bool invincible (flag & (1 << 3)) != 0
0이면 무적 아니면 아니고


const와 메모리 구조
---
const : 변수를 상수화 함

메모리 구조
// [데이터 영역]
.data -> 초기값 있는 경우
    => int a = 2;
.bss -> 초기 값 없는 경우
    => int b;
.rodata -> 읽기 전용 데이터
    => const char* msg = "Hello World"

1) const는 그럼 어디로 저장되는가??
=> 사실 정해진건 없다, 컴파일러 마음
=> 컴파일러가 자체적으로 설정 값으로 바꾸기 때문에 메모리 할당이 안되있을수도 있음

2) 함수내에서 const 변수를 만들면??
=> 스택 영역에 만들어짐


유의사항
1) 변수의 유효범위
    - 함수 외부의 선언 했을때 => 전역 변수
    언제 어디서든 쓸 수있는

    - 특정 함수 내부에 선언 했을때 => 스택에 들어가는 변수, { } 의 범위가 생존 범우

2) 연산 우선순위
    - 연산자마다 우선순위가 있으니 유의
    - 필요한 경우 ( )로 감싸 변경

3) 타입 변환
    - 선언한 변수의 자료형을 바꿀때 -> 캐스팅

4) 사칙연산
    - 정수 / 정수를 실수에 저장하고 싶다면 소숫점 밑이 잘려 저장되기 때문에 float으로 저장해도 소숫점이 잘림


함수 ( 프로시저, 메소드, 루틴 )

오버로딩 ( 중복 정의 : 함수 이름의 재사용 )
-> 매개변수 갯수가 다르거나
-> 매개변수 타입이 다르거나 (순서가 다른걸 포함)

기본 인자값
함수선언때 미리 기본값을 선택할수있음
이런식으로 기본값을 정의할 변수는 항상 마지막에 정의


** 포인터 **
특정 공간에 있는 메모리에 접근하는 방법 = 주소를 담는 변수
주소를 저장하기 때문에 체계에 따라 크기가 다름
32비트 = 4바이트 / 64비트 = 8바이트 고정 크키

) 포인터에 타입을 정하는 이유
-> 주소에 도착했을때 값이 어떤 형태인지 명시하기위해

) 타입의 불일치
-> 자료형을 잘못 사용할경우 데이터 손실이 발생함

** 포인터 연산
1) 주소 연산자(&)
-> 해당 변수의 주소를 가져옴
-> 정확히는 해당 변수 타입에 따라서 Type* 변환

2) 산술 연산자 (+ -)
-> 포인터나 +나 -등 산술 연산하면 Type의 크기만큼 연산하라는 뜻

3) 간접 연산자 (*)
-> 해당 주소로 가는것

4) 간접 멤버 연산자 (->)
-> (*ABC).??? = ABC->
-> 구조체의 특정 멤버를 다룰때 사용 ( 어셈블리 언어로 보면 (.) 사실상 그냥 덧셋)

*포인터 vs 참조
1) 편의성 관련
-> 성능은 똑같고 편의성이 더 좋은 참조만 쓸수는 없음
-> 포인터는 주소나 원본을 넘기는지를 확실히 알 수 있으나 참조는 모르고 지나칠 수 있음, 즉 원본훼손의 여지를 느낄수 있음
=> 참조는 변경하지 말라고 const와 같이 사용 많이함 (const StatInfo& ...)

*const의 앞과 뒤에 *(포인터)가 붙는 의미
-> (type)* const .. = 변수의 주소값을 바꾸지못함 주소값 고정
-> const (type)* = 주소값이 아닌 주소안의 내용물을 바꾸지못함 = 내용물 고정


2) 초기화 여부
-> 참조 타입은 두번째 이름이기 때문에 참조하는 대상이 없으면 안됨.
-> 반면 포인터는 그냥 어떤 ~ 주소라는 의미 : 대상이 실존하지 않을 수도 있음
-> 포인터에서 '없다'는 의미는 ? : nullptr
-> 참조 타입은 이런 nullptr이 존재하지 않음.
=> 없다는 표현을 참조는 할 수 없는게 포인트

// 결론 //
답은 없고 Team by Team
구글은 포인터를 많이 쓰고 언리얼은 레퍼런스를 많이 쓰더라

================

*배열 
배열의 이름은 곧 배열의 시작주소
정확히는 시작 위치를 가리키는 type* 포인터

*포인터 vs 배열
-> 배열을 함수 인자로 넘기면, 컴파일러가 알아서 포인터로 치환 ( char[] -> char* )
=> 배열을 넘기는 것은 배열의 시작 주소를 넘긴것

*파일 분할 관리
헤더와 .cpp 파일의 대한 이야기
선언부와 구현부의 분할

#pragma once => 같은 부분을 두번 선언하지 않게끔 해주는
#indef ... #define .. #endif 라는 옛버전도 있음
헤더파일은 최대한 간단하게


# 객체지향의 시작
객체란?
---
-> 플레이어, 몬스터, GameRoom등의 오브젝트의 개념적 통칭
-> 일종의 설계도인  클래스의 등장
-> 다양한 변수의 유효범위들을 클래스라는 틀에 묶어 하나의 덩치로써 인식

생성자와 소멸자
---
-> 클래스내의 특별한 함수 2종
-> 시작의 생성자 (여러개 존재 가능)
-> 끝의 소멸자 (오직 1개만)

1) 기본 생성자 ( 인자가 없음 )
-> 아무것도 없어도 자동으로 호줄되는 기본 폼
-> 클래스 소속 멤버 변수들의 초기화 가능

) 암시적(implicit) 생성자
-> 생성자를 명시적으로 만들지 않으면 아무 인자도 받지 않는 기본 생성자가 컴파일러에 의해 자동으로 만들어짐
-> 프로그래머가 명시적으로 만들면 자동적으로 만들어주지 않음

2) 복사 생성자
-> TYPE(const TYPE& name) { }
-> 자기 클래스 참조 타입을 인자로 받음
-> 일반적으로 똑같은 데이터를 지닌 객체가 생성되길 기대

3) 그외... 기타 생성자 ( 타입 변환 생성자 )
-> 프로그래머 필요에 의한 내용

상속성
---
-> 부모 <=> 자식, 무언가를 물려주는 것, 코드 재사용성 향상
-> 상위 클래스의 기능들을 하위 클래스가 사용하면서 하위 클래스 하나만의 특징을 지정 할 수 있음
-> 메모리상 상위클래스가 먼저 생성된후 밑에 하위클래스가 생성
-> 하위클래스가 상위클래스의 기능, 함수를 재정의 가능
-> 하위클래스를 생성하면 상위클래스의 생성자를 먼저 부르고 소멸시킬 시에는 반대로 하위클래스의 소멸자를 먼저 부름
-> 상위클래스의 생성자의 종류도 명시적으로 사용가능
ex) type2(int ..) : type1(float ..)

은닉성 = 캡술화 ( 연관된 데이터와 함수를 논리적으로 묶어놓은 것)
---
-> 숨기는 이유 : ) 위험하고 건드리면 안되는 경우
) 다른 경로로 접근하길 원하는 경우
-> 상속 접근 지정자 : 다음 세대에게 상속 받은 내용을 어느정도까지 내려받을지
) public : 그래도 다
) protected : 자기 직속 하위클래스일때만, 1차 하위는 상속받지만 2차 하위는 못받음
) private : 안줌

다형성
---
-> 형태는 같지만, 기능이 다르게 동작 
( 오버로딩 : 함수 중복 정의 = 함수 이름의 재사용 오버라이딩 : 재정의 = 상위 클래스의 함수를 하위 클래스에서 재정의)
-> 바인딩
    => 정적 바인딩(static binding) : 컴파일 시점에 결정
    => 동적 바인딩(dynamic binding) : 실행 시점에 결정
-> 일반 함수는 정적 바인딩을 실행
-> 동적 바인딩을 원한다면? -> 가상 함수 사용

*가상함수 테이블 (vftable)*
-> 실제 객체가 어떤타입인지 어떻게 알고 알아서 가상함수를 호출하는지의 대한 해답
-> 가상함수들의 주소들을 객체마다 저장하고 있다가 지정받은 객체 버전의 함수 주소로 가서 실행 

-> 순수 가상 함수 : 구현은 없고 인터페이스만 전달하는 용도로 사용하고 싶을 경우
-> 추상 클래스 : 순수 가상 함수가 1개 이상 포함되면 추상 클래스가 됨
    => 이는 직접적으로 객체를 만들 수 없게 됨
    => 하위 클래스가 어떻게는 순수 가상 함수를 재정의해서 사용해야함


초기화 리스트
---
-> 초기화를 해야 하는 이유
    => 버그 예방에 중요
    => 포인터 등 주소값이 연루되어 있을 경우

-> 초기화 방법
    => 생성자 내에서
    => *초기화 리스트
        - 상속 관계에서 원하는 부모 생성자 호출할때 필요
        - 생성자 내에서 초기화 vs 초기화 리스트
        > 일반 변수는 별 차이 없음
        > 멤버 타입이 클래스인 경우 차이가 남
        > 정의함과 동시에 초기화가 필요한 경우 ( 참조 타입, const 타입)
    => C++11 문법
        type name = 바로 ;
-> 두 클래스가 상속 관계였을 경우 전처리 영역외에 클래스의 정의를 내릴경우 객체가 한개 더 생길 수 있음

연산자 오버로딩
---
기본으로 제공되는 연산을 제외한 커스텀 연산이 필요할떄 사용

함수 오버로딩과 다른점 : 연산자는 피연산자의 개수/타입이 고정되어 있음

  -RET operator+ (ARG_List) { }-

-멤버 연산자 함수
-> a op b 형태에서 왼쪽을 기준으로 실행됨 (a가 클래스여야 가능, a를 '기준 피연산자'라고 함)
    => 한계) a가 클래스가 아니면 사용 못함

-전역 연산자 함수
-> a op b 형태라면, a,b모두를 연산자 함수의 피연산자로 만등러줌
-> 멤버 연산자 함수의 한계를 극복하려는 것
-> 대입 연산자(=)는 전역에서 생성이 불가능

-복사 대입 연산자

-static 변수, static 함수
-> 클래스변수와 비슷하지만 단일 객체에 연관이 아니라 그 객체 자체와 연관됨

-> static 함수는 전역함수처럼 동작하기 때문에 static 변수를 건드릴땐 문제없지만 특정 객체와 연관성이 생기면 안됨

-> 초기화 하면 .data 영역, 안하면 .bss 영역에 저장됨

# 동적 할당
메모리 구조 복습
-실행할 코드가 저장되는 영역 -> 코드 영역
-전역(global)/정적(static)변수 -> 데이터 영역

-지역 변수/매개 변수 -> 스택 영역
-함수가 끝나면 같이 정리되는 불안정한 메모리
    -> 잠시 함수에 매개변수 넘긴다거나, 하는 용도

-동적 할당 -> 힙 영역
    -> 필요할때만 사용, 필요없으면 반납
    -> 생성/소멸 시점을 관리 가능
---

/ 유저영역(메모장, 롤, 곰플레이어)
/ ------------------
/ 커널영역 ( Windows 핵심 코드)

-유저가 운영체제에서 제공하는 API를 호출하면 커널 영역에서 메모리를 할당해서 건네줌

-C++에서는 CRT(C런타임 라이브러리)의 [힙 관리자]를 통해 힙 영역 사용.
-정말 원하면 직접 API를 통해 힙을 생성하고 관리 가능 ( MMORPG 서버 메모리 풀링 )

-malloc
    -> 할당할 메모리 크기를 건네줌
    -> 메모리 할당 후 시작 주소를 가리키는 포인터를 반환 ( 메모리 부족시 NULL )
    -> void* 형태를 반환하나 아무것도 없다는 뜻이 아니라 뭐가 쓰일지 모른다는 뜻

-free
    -> malloc 같은 메모리 할당을 통해 할당된 영역을 해제
    -> 힙 관리자가 할당/미할당 여부를 구분해서 관리

-new / delete 가 위 예시보다 편의성이 좋음
-타입에 상관없이 특정한 크기의 메모리 영역을 할당 받으려면 malloc / free가 좋음

-둘의 차이 첫째는 malloc/free는 함수, new/delete는 연산자임
-둘의 근본적인 차이는 
'new/delete'는 생성타입이 클래스일 경우 생성자/소멸자를 호출함  