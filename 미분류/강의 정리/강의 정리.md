C++
======

스택에서
--------
0이 아닌 초기화가 되어있으면 .data 영역
초기값이 0 이거나 초기값이 없으면 .bss 영역


정수
---
char a; => 1 바이트
short b; => 2 바이트
int c; => 4 바이트
__int64 d; => 8 바이트 (long long)

bool => 1 바이트 정수에 불과
=

실수(부동소수점)
----
.(점) 을 유동적으로 움직여서 표현하는 방법
    -> 프로그래밍 상 항상 근삿값

float => 4 바이트
    - 부호(1) 지수(8) 유효숫자(23) = 32비트
double => 8 바이트, (기본 자료형)
    - 부호(1) 지수(11) 유효숫자(52) = 64비트

ex) -3.375
    => 1) 2진수 변환 = (3) + (0.375) = ob11 + 0b0.011
       2) 정규화 = 0b1.1011 * 2
    
    1(부호) 1(지수) 1011(유효숫자)
    단 지수는 unsigned byte라고 가정하고 숫자 + 127 만들어줌


문자와 문자열
---
문자
char : 알파벳 / 숫자 문자   // cout
wchar_t : 유니코드 문자 (UTF16 으로 저장) // mcout

UTF8
-> 알파벳, 숫자 1바이트(ASCII 동일한 번호)
-> 유럽 지역의 문자는 2바이트
-> 한글, 한자 등 3바이트
UTF16
-> 알파벳, 숫자, 한글, 한자 등 거의 대부분 2바이트
-> 매--우 예외적인 고대 문자만 4바이트(사실상 x)

\t = 아스키코드9 = Tab
\n = 아스키코드10 = LineFeed (한줄 아래로)
\r = 아스키코드13 = CarriageReturn (커서 <<)
\' = 따옴표같은 문자 표시
\0 = 아스키코드0 = NULL

문자열
끝은 NULL (ASCII 0)
Data 영역에서 초기화하면 0으로 초기화되서 잘 나오지만 Stack 영역에서 초기화하면 0이 없어 0이 나올때까지 멋대로 찾아다녀 쓰레기 값이 나옴

""를 이용해서 초기화하면 뒤에 NULL이 붙음

비트 연산
---
비트 단위의 조작이 필요할 때
-> 게임에서 ID를 검색할때, *BitFlag

~ : bitwise not 
=> 단일 숫자의 모든 비트를 대상으로 , 0은 1, 1은 0으로 뒤바꿈

& : bitwise and
=> 두 숫자의 모든 비트 쌍을 대상으로 and 연산

| : bitwise or
=> 두 숫자의 모든 비트 쌍을 대상으로 or 연산

^ : bitwise xor
=> 두 숫자의 모든 비트 쌍을 대상으로 xor 연산
=> 암호화할떄 유용, 두번 xor 연산하면 오리지널이 나옴

<< : 비트 좌측으로 이동
=> 왼쪽에 넘치는 N개의 비트는 버리고 복원이 안됨. 오른쪽은 0으로 채움
=> 비트 연산시 *2를 할때 컴파일러가 자주 하는 패턴

'>> : 비트 우측 이동
=> 비트열을 N만큼 오른쪽으로 이동
=> 마찬가지로 이동시 버리고 왼쪽에 생기는 N개의 비트는 ~부호 비트가 존재할 경우 부호 비트를 따라감, 아니면 0

*비트플래그
-> bool노가다를 줄이는 방법

ex) unsigned char flag; // 부호를 없애야 >>를 해도 부호가 안따라옴

-- 0b0000 [무적][변이][스턴][공중부양]
=> flag = (1 << 3); = 무적 상태로 만듬
=> flag = (1 << 2); = 변이 상태로 만듬

무적 + 변이
=> flag |= 4; // flag (1 << 2);

확인 방법
*bitmask

// 무적인지 확인
bool invincible (flag & (1 << 3)) != 0
0이면 무적 아니면 아니고


const와 메모리 구조
---
const : 변수를 상수화 함

메모리 구조
// [데이터 영역]
.data -> 초기값 있는 경우
    => int a = 2;
.bss -> 초기 값 없는 경우
    => int b;
.rodata -> 읽기 전용 데이터
    => const char* msg = "Hello World"

1) const는 그럼 어디로 저장되는가??
=> 사실 정해진건 없다, 컴파일러 마음
=> 컴파일러가 자체적으로 설정 값으로 바꾸기 때문에 메모리 할당이 안되있을수도 있음

2) 함수내에서 const 변수를 만들면??
=> 스택 영역에 만들어짐


유의사항
1) 변수의 유효범위
    - 함수 외부의 선언 했을때 => 전역 변수
    언제 어디서든 쓸 수있는

    - 특정 함수 내부에 선언 했을때 => 스택에 들어가는 변수, { } 의 범위가 생존 범우

2) 연산 우선순위
    - 연산자마다 우선순위가 있으니 유의
    - 필요한 경우 ( )로 감싸 변경

3) 타입 변환
    - 선언한 변수의 자료형을 바꿀때 -> 캐스팅

4) 사칙연산
    - 정수 / 정수를 실수에 저장하고 싶다면 소숫점 밑이 잘려 저장되기 때문에 float으로 저장해도 소숫점이 잘림


함수 ( 프로시저, 메소드, 루틴 )
-스택 프레임