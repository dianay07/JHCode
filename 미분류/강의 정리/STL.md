# STL
= Standard Template Library
프로그래밍할 때 필요한 자료구조/알고리즘들을 템플릿으로 제공하는 라이브러리

컨테이너 (Container) : 데이터를 저장하는 객체 ( 자료구조 data structure )


Vector ( 동적 배열 )
---
- vector의 동작 원리 (size/capacity)
    size : 실제 사용 데이터 갯수
    vector<type>.resize : 사이즈 강제 조정
        -> 이런식으로 강제를 늘릴경우 push_back은 늘려진 끝부터 사용함
    capacity : 여유분을 포함한 용량 갯수
    vector<type>.reserve : 캐퍼시티 강제 조정

-> 미리 reserve로 용량을 키워놓고 작업한다면 push_back할때마다 등장한 복사 이동 작업이 불필요해짐

// 동적 배열은 어떤 식으로 배열을 유동적으로 사용하나

1) (여유분을 두고) 메모리를 할당
2) 여유분까지 꽉 차면, 메모리를 추가함
    -> 기존 영역을 없애고 다른 영역으로 확장

의문 1) 여유분은 얼만큼이 적당한가
    -> 1.5배 내지 2배씩 늘리는데 이는 원소를 추가할때 마다 발생하는 원소 복사 비용의 절감을 위해
의문 2) 확장은 얼마나 해야 하나
의문 3) 기존의 데이터를 어떻게 처리하는가

// vector<type>.size()의 리턴값이 unsigned_int기 때문에 빌드시 warning이 뜨는데, 이는 for문의 시작지점 타입을 int가 아닌 vector<int>::size_type으로 자동완성 시켜주면 사라짐     ->     자료구조책에서 많이 보던 모양이 왜 그랫는지, C++11문법이랗

- 중간 삽입/삭제 ( BAD )
    -> c++ 실력의 척도가 될수 있는 개념
    -> 원소가 하나의 메모리 블록에 '연속하게' 저장되야 한다는 규칙을 지켜야함
    -> 중간에서 이러는게 비효율적인건 확실   
- 처음/끝 삽입/삭제 ( BAD / GOOD )
    -> 맨 마지막 원소를 가지고 행동하는건 효율적
    -> push_back, pop_back 인터페이스가 지원되는 이유

- 임의 접근 ( Random Access )
    -> 연속하게 저장됨이 보장되면 찾을수 있음
    -> i 번째에 접근하고 싶다 할때 1번째 주소에서 출발할 수 있으면 계산이 빠르기때문에 

- 쭉 스캔하면서, 임의의 데이터를 일괄 삭제하고 싶다?
    -> iter를 이용한 for문을 쓸때 포인터 주소로 작용하기 때문에 잘 생각해야댐


리스트 ( 연결 리스트 )
---
- list의 동작 원리 
    단일 , 이중 , 원형
    벡터와 달리 원소끼리 다음 원소의 위치만 알고 연속되어있을 필요는 없음
- 중간 삽입/삭제
- 처음/끝 삽입/삭제
- 임의 접근